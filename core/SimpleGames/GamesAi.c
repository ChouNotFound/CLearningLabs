/******************************************************************************
 * @file    GamesAi.c
 * @author  Generated by AI Assistant
 * @date    2025-10-28
 ******************************************************************************
 * Description:
 *   游戏AI模块，包含井字棋AI的实现
 *
 * Functions:
 *   - aiMakeMove() : AI进行下一步棋
 ******************************************************************************
 * @version 1.0
 ******************************************************************************/

/*=============================================================================
 *                           头文件包含区
 *===========================================================================*/

#include "GamesAi.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/*=============================================================================
 *                          宏定义区
 *===========================================================================*/

/*=============================================================================
 *                          类型定义区
 *===========================================================================*/

/*=============================================================================
 *                          全局变量区
 *===========================================================================*/

/*=============================================================================
 *                          函数声明区
 *===========================================================================*/

static int checkWin(char board[3][3], char player);
static int isBoardFull(char board[3][3]);
static char getOpponent(char player);
static int minimax(char board[3][3], int depth, int isMaximizing, char aiPlayer);

/*=============================================================================
 *                          函数实现区
 *===========================================================================*/

// 检查指定玩家是否获胜
static int checkWin(char board[3][3], char player)
{
    // 检查行
    for (int i = 0; i < 3; i++) 
    {
        if (board[i][0] == player && board[i][1] == player && board[i][2] == player)
            return 1;
    }
    
    // 检查列
    for (int j = 0; j < 3; j++) 
    {
        if (board[0][j] == player && board[1][j] == player && board[2][j] == player)
            return 1;
    }
    
    // 检查对角线
    if (board[0][0] == player && board[1][1] == player && board[2][2] == player)
        return 1;
    if (board[0][2] == player && board[1][1] == player && board[2][0] == player)
        return 1;
        
    return 0;
}

// 检查棋盘是否已满
static int isBoardFull(char board[3][3])
{
    for (int i = 0; i < 3; i++) 
    {
        for (int j = 0; j < 3; j++) 
        {
            if (board[i][j] == ' ')
                return 0;
        }
    }
    return 1;
}

// 获取对手符号
static char getOpponent(char player)
{
    return (player == 'X') ? 'O' : 'X';
}

// AI使用Minimax算法进行最佳移动
static int minimax(char board[3][3], int depth, int isMaximizing, char aiPlayer)
{
    char opponent = getOpponent(aiPlayer);
    
    // 检查是否AI获胜
    if (checkWin(board, aiPlayer))
        return 10 - depth;
    
    // 检查是否对手获胜
    if (checkWin(board, opponent))
        return depth - 10;
    
    // 检查是否平局
    if (isBoardFull(board))
        return 0;
    
    if (isMaximizing) 
    {
        int bestScore = -1000;
        for (int i = 0; i < 3; i++) 
        {
            for (int j = 0; j < 3; j++) 
            {
                if (board[i][j] == ' ') 
                {
                    board[i][j] = aiPlayer;
                    int score = minimax(board, depth + 1, 0, aiPlayer);
                    board[i][j] = ' ';
                    if (score > bestScore)
                        bestScore = score;
                }
            }
        }
        return bestScore;
    } 
    else 
    {
        int bestScore = 1000;
        for (int i = 0; i < 3; i++) 
        {
            for (int j = 0; j < 3; j++) 
            {
                if (board[i][j] == ' ') 
                {
                    board[i][j] = opponent;
                    int score = minimax(board, depth + 1, 1, aiPlayer);
                    board[i][j] = ' ';
                    if (score < bestScore)
                        bestScore = score;
                }
            }
        }
        return bestScore;
    }
}

void aiMakeMove(char board[3][3], char aiPlayer)
{
    int bestScore = -1000;
    int bestMoveRow = -1, bestMoveCol = -1;
    
    for (int i = 0; i < 3; i++) 
    {
        for (int j = 0; j < 3; j++) 
        {
            if (board[i][j] == ' ') 
            {
                board[i][j] = aiPlayer;
                int score = minimax(board, 0, 0, aiPlayer); // 下一层是对手回合，所以是0
                board[i][j] = ' ';
                if (score > bestScore) 
                {
                    bestScore = score;
                    bestMoveRow = i;
                    bestMoveCol = j;
                }
            }
        }
    }
    
    if (bestMoveRow != -1 && bestMoveCol != -1) 
    {
        board[bestMoveRow][bestMoveCol] = aiPlayer;
    }
}